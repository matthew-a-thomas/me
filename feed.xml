<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-08-30T21:41:06-05:00</updated><id>/feed.xml</id><entry><title type="html">The Vanity of Modern Cosmology</title><link href="/misc/2022/08/30/vanity-modern-cosmology.html" rel="alternate" type="text/html" title="The Vanity of Modern Cosmology" /><published>2022-08-30T00:00:00-05:00</published><updated>2022-08-30T00:00:00-05:00</updated><id>/misc/2022/08/30/vanity-modern-cosmology</id><content type="html" xml:base="/misc/2022/08/30/vanity-modern-cosmology.html"><![CDATA[<p><a href="https://www.google.com/search?q=cosmology+definition">Google says</a> that
“cosmology” is:</p>

<blockquote>
  <p><em>noun</em></p>

  <p>the science of the origin and development of the universe. Modern astronomy is
  dominated by the Big Bang theory, which brings together observational
  astronomy and particle physics.</p>
  <ul>
    <li>an account or theory of the origin of the universe.</li>
  </ul>
</blockquote>

<p>Wikipedia has an article titled
“<a href="https://en.wikipedia.org/wiki/Timeline_of_the_far_future">Timeline of the far future</a>”.
The article spans an unfathomable stretch of time from the near present all the
way out to \(10^{10^{10^{56}}}\) years in the future. As of this writing it
cites 209 references from a broad range of sources, including many who are
highly regarded by the scientific community. In its own words:</p>

<blockquote>
  <p>While the future cannot be predicted with certainty, present understanding in
  various scientific fields allows for the prediction of some far-future events,
  if only in the broadest outline. These fields include astrophysics, which
  studies how planets and stars form, interact, and die; particle physics, which
  has revealed how matter behaves at the smallest scales; evolutionary biology,
  which predicts how life will evolve over time; plate tectonics, which shows
  how continents shift over millennia; and sociology, which examines how human
  societies and cultures evolve.</p>
</blockquote>

<p>The article draws on a wide range of people from a wide range of fields.</p>

<p>I don’t think it’s a stretch to say that article presents a sketch of modern
cosmology.</p>

<h2 id="the-future-and-its-impact">The future and its impact</h2>

<p>What does the future hold?</p>

<p>You probably have a good idea of how tomorrow is going to pan out. For most
people it’ll be very unsurprising. You’ll wake up, eat breakfast, go to work,
and so on. Tomorrow you’ll eat lunch because you won’t want to be hungry before
suppertime rolls around.</p>

<p>Later this week or perhaps later this month you’ll have a bill to pay. If you
don’t pay that bill then you’ll be sent to collections. And so you’ll go to
work and will earn your paycheck. And you have other things that you’ll want to
do in the future, so you make plans to spend your paycheck on those things too.</p>

<p>You probably do a great many things because <em>you foresee something in the
future</em>. In a word, future events drive, control, motivate, and govern your
actions now.</p>

<h2 id="the-oughtness-of-the-future">The oughtness of the future</h2>

<p>What ought you do today? It depends a lot on what the future will bring.</p>

<p>Is it going to rain this afternoon? Then you ought to bring an umbrella with you
when you go out.</p>

<p>How many market cycles have you lived through and afterward thought “I
ought to have distributed my investments in a different manner”?</p>

<p>Are you working hard on a large project now because you believe it will be
important in the future? In that case you attribute value to your present work
because you anticipate that the outcome of your work will be valuable in the
future.</p>

<h2 id="the-future-of-modern-cosmology">The future of modern cosmology</h2>

<p>These are the most distant events anticipated by the Wikipedia article I linked
to above:</p>

<table>
  <thead>
    <tr>
      <th>Years in the future</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(10^{10^{76}}\)</td>
      <td>Beyond this point, it is almost certain that the universe will be an almost pure vacuum, with all baryonic matter having decayed into subatomic particles, until it reaches its final energy state, assuming it does not happen before this time.</td>
    </tr>
    <tr>
      <td>\(10^{10^{120}}\)</td>
      <td>Highest estimate for the time it takes for the universe to reach its final energy state.</td>
    </tr>
    <tr>
      <td>\(10^{10^{10^{56}}}\)</td>
      <td>Around this vast timeframe, quantum tunnelling in any isolated patch of the universe could generate new inflationary events, resulting in new Big Bangs giving birth to new universes.</td>
    </tr>
  </tbody>
</table>

<p>To put it crassly, modern cosmology says everything is going to fizzle away into
nothing.</p>

<p>And then it’ll start over again. These “new inflationary events” aren’t one-off
events; it’s cyclical.</p>

<h2 id="vanity-of-vanities">Vanity of vanities</h2>

<p>Have you ever read Ecclesiastes? Here’s how
<a href="https://www.esv.org/Ecclesiastes+1/">chapter one</a> starts:</p>

<blockquote>
  <p>Vanity of vanities, says the Preacher,<br />
	  vanity of vanities! All is vanity.<br />
	What does man gain by all the toil<br />
	  at which he toils under the sun?<br />
	A generation goes, and a generation comes,<br />
  but the earth remains forever.<br />
	The sun rises, and the sun goes down,<br />
	  and hastens to the place where it rises.<br />
	The wind blows to the south<br />
	  and goes around to the north;<br />
	around and around goes the wind,<br />
	  and on its circuits the wind returns.<br />
	All streams run to the sea,<br />
	  but the sea is not full;<br />
	to the place where the streams flow,<br />
	  there they flow again.<br />
	All things are full of weariness;<br />
	  a man cannot utter it;<br />
	the eye is not satisfied with seeing,<br />
	  nor the ear filled with hearing.<br />
	What has been is what will be,<br />
	  and what has been done is what will be done,<br />
	  and there is nothing new under the sun.<br />
	Is there a thing of which it is said,<br />
	  “See, this is new”?<br />
	It has been already<br />
	  in the ages before us.<br />
	There is no remembrance of former things,<br />
	  nor will there be any remembrance<br />
	of later things yet to be<br />
	  among those who come after.<br /></p>
</blockquote>

<p>Ecclesiastes is basically an apologetic against the worldviews that were
competing against ancient Hebrew thought at that time. Those worldviews thought
that history was cyclical, and Solomon’s book makes it very clear how pointless
such a history would be. On the other hand, history in the eyes of the Hebrew
Bible is linear with a definite beginning and certain goal.</p>

<p>Modern cosmology falls squarely in the sights of Ecclesiastes.</p>

<h2 id="the-vanity-of-modern-cosmology">The vanity of modern cosmology</h2>

<p>Not only are you supposed to believe that nobody will ever remember or care
about anything you do. You’re also supposed to believe that the same thing is
going to happen to someone else somewhere else. Over and over again forever.</p>

<p>Why should you go to work tomorrow? According to modern cosmology your work is
going to fizzle away and be forgotten. And then eventually someone else
somewhere else is going to do whatever you are going to do tomorrow, whether you
do it or not. So why not just stay home?</p>

<p>On the one hand you can get away with whatever you want because nobody is
watching, or if they are their opinion doesn’t really matter in the grand scheme
of things because they’re destined to be just a fizzled out nothing.</p>

<p>But on the other hand there is no glory in anything you do, because you also are
destined to be just a fizzled out nothing.</p>

<p>To put it simply, there is no “oughtness” to modern cosmology.</p>

<h2 id="the-weight-and-consequence-of-biblical-cosmology">The weight and consequence of Biblical cosmology</h2>

<p>In sharp contrast, the Bible is very clear that history has a date of
manufacture. That was a few thousand years ago when God started saying things.</p>

<p>And it is also clear that history is on a very intentional trajectory leading
through a series of intentional events planned and executed by a sovereign and
wise God.</p>

<p>For example, the Day of Judgment is coming when “the heavens will pass away with
a roar, and the heavenly bodies will be burned up and dissolved, and the earth
and the works that are done on it will be exposed” (2 Peter 3:10).</p>

<p>There is a God who made you. Therefore you are accountable to him. Furthermore
he has fixed a Day of Judgment and has gone to great lengths to make two things
clear: you are a sinner who is not able to make it through that Day; and there
is a savior who is able to bring you through unscathed.</p>

<p>Not only <em>ought</em> you to go to work (because God said so in 2 Thessalonians
3:6–12)—it’s possible for your work tomorrow to be eternally
significant (because God will reward whatever service is rendered to
him—Ephesians 6:7–8).</p>]]></content><author><name></name></author><category term="misc" /><summary type="html"><![CDATA[The future of things, and the point thereof]]></summary></entry><entry><title type="html">ReentrantAsyncLock NuGet Package</title><link href="/programming/2022/06/20/introducing-reentrantasynclock.html" rel="alternate" type="text/html" title="ReentrantAsyncLock NuGet Package" /><published>2022-06-20T00:00:00-05:00</published><updated>2022-06-20T00:00:00-05:00</updated><id>/programming/2022/06/20/introducing-reentrantasynclock</id><content type="html" xml:base="/programming/2022/06/20/introducing-reentrantasynclock.html"><![CDATA[<p>This is the third post in a short series about async
locks:</p>

<ol>
  <li><strong><a href="/programming/2022/06/14/reentrant-async-lock.html">Reentrant Async Lock</a></strong>—A correct implementation</li>
  <li><strong><a href="/programming/2022/06/15/ergonomic-async-lock.html">A More Ergonomic Async Lock (obsolete)</a></strong>—Making the work queue look more like an async lock</li>
  <li><strong>ReentrantAsyncLock NuGet Package</strong> (<em>this post</em>)—Introducing the ReentrantAsyncLock package</li>
  <li><strong><a href="/programming/2022/06/20/questions-answered.html">Questions Answered</a></strong>—Answering some questions about ReentrantAsyncLock</li>
</ol>

<hr />

<p>In the previous two posts I outlined the concept for a reentrant asynchronous
lock, and explained how it can provide all three of these things at once:</p>

<ul>
  <li>Reentrance</li>
  <li>Asynchronicity</li>
  <li>Mutual exclusion</li>
</ul>

<p>In this third post I’ll introduce the ReentrantAsyncLock NuGet package which
gives you semantics that will look a little more normal. I think this third post
should take the place in your mind of the second one because the code here works
out some kinks that I inadvertently have there. I consider this NuGet package
the capstone of my efforts in this series.</p>

<p>NuGet package:<br />
<a href="https://www.nuget.org/packages/ReentrantAsyncLock">https://www.nuget.org/packages/ReentrantAsyncLock</a></p>

<p>Source code:<br />
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock">https://github.com/matthew-a-thomas/cs-reentrant-async-lock</a></p>

<h1 id="the-nuget-package-and-its-semantics">The NuGet package and its semantics</h1>

<p>The
<a href="https://www.nuget.org/packages/ReentrantAsyncLock">ReentrantAsyncLock NuGet package</a>
lets you write code like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">asyncLock</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ReentrantAsyncLock</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">raceCondition</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="c1">// You can acquire the lock asynchronously</span>
<span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">// The lock is reentrant</span>
            <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="c1">// The lock provides mutual exclusion</span>
                <span class="n">raceCondition</span><span class="p">++;</span>
            <span class="p">}</span>
        <span class="p">}),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">raceCondition</span><span class="p">++;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">raceCondition</span><span class="p">);</span>
</code></pre></div></div>

<p>In the code comments above I point out the three different aspects of the lock.</p>

<p>You’ll also notice that the NuGet package source code has automated tests that
assert the correctness of each of the three aspects (and more).</p>

<h1 id="how-does-it-work">How does it work?</h1>

<p>It combines <code class="language-plaintext highlighter-rouge">ExecutionContext</code>/<code class="language-plaintext highlighter-rouge">AsyncLocal</code> with a special
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code> and a special awaitable type.</p>

<h2 id="executioncontext-and-asynclocal">ExecutionContext and AsyncLocal</h2>

<p>If you’re familiar with
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.executioncontext?view=net-6.0">the ExecutionContext class</a>
then you’ll know that it “flows” downward through async calls. And it carries
some stuff with it. In particular, it carries the values of
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-6.0">AsyncLocal</a>
instances.</p>

<p>One such instance holds a value that indicates an asynchronous scope. When you
acquire the lock then your scope is squirreled away as though to say “the lock
belongs to this scope”. And then that scope flows downward through async calls.
That’s what makes the lock reentrant.</p>

<p>If you’re looking at the source code then check out
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/blob/deded4441ad895428dc3716852e5fb07c74036af/ReentrantAsyncLock/ReentrantAsyncLock.cs#L84">the <code class="language-plaintext highlighter-rouge">ReentrantAsyncLock.LocalScope</code> property</a>.
It is backed by an <code class="language-plaintext highlighter-rouge">AsyncLocal</code> instance and stores a value that indicates an
asynchronous scope. When an object is assigned to this property then all nested
async calls also get that value.</p>

<p>Now notice
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/blob/deded4441ad895428dc3716852e5fb07c74036af/ReentrantAsyncLock/ReentrantAsyncLock.cs#L149">the <code class="language-plaintext highlighter-rouge">ReentrantAsyncLock.TryLockImmediately</code> method</a>.
That method checks the <code class="language-plaintext highlighter-rouge">LocalScope</code> against
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/blob/deded4441ad895428dc3716852e5fb07c74036af/ReentrantAsyncLock/ReentrantAsyncLock.cs#L63">the <code class="language-plaintext highlighter-rouge">_owningScope</code> field</a>.
When they match then the lock can be acquired because that’s a case of
reentrance.</p>

<h2 id="synchronizationcontext">SynchronizationContext</h2>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-6.0">The <code class="language-plaintext highlighter-rouge">SynchronizationContext</code> class</a>
is Microsoft’s abstraction of a synchronization model. It is (usually) the thing
in charge of deciding how asynchronous continuations should be executed.</p>

<p>For example, in WPF when you are executing asynchronous code on the UI thread
then you’ll want to still be on the UI thread after an <code class="language-plaintext highlighter-rouge">await</code> call:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">partial</span> <span class="k">class</span> <span class="nc">MyUserControl</span>
<span class="p">{</span>
  <span class="cm">/* Notice this is an "async" method: */</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">OnButtonClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">5</span><span class="p">));</span>
    <span class="nf">DoSomethingSynchronousOnTheUIThread</span><span class="p">();</span> <span class="c1">// &lt;-- This needs to happen on the UI thread</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>WPF has
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatchersynchronizationcontext?view=windowsdesktop-6.0">a special subclass of <code class="language-plaintext highlighter-rouge">SynchronizationContext</code></a>
that enables this.</p>

<p>I do something similar in the <code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code> package. I subclassed
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code> so that I could serialize continuations and execute
them one-at-a-time.</p>

<p>Check out
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/blob/deded4441ad895428dc3716852e5fb07c74036af/ReentrantAsyncLock/WorkQueue.cs">my <code class="language-plaintext highlighter-rouge">WorkQueue</code> class</a>.
It’s the same thing that I described in
<a href="/programming/2022/06/14/reentrant-async-lock.html">the first post</a>.</p>

<p>It’s just a simple work queue. But that’s what gives the lock mutual exclusion.</p>

<p>Recall how you acquire the lock:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="n">asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</code></pre></div></div>

<p>When you invoke <code class="language-plaintext highlighter-rouge">LockAsync</code> then you are immediately placed on that
SynchronizationContext. The compiler packages up the code after the <code class="language-plaintext highlighter-rouge">await</code> into
a continuation, and that continuation is given to the work queue. And since that
work queue will only do one thing at a time you get mutual exclusion.</p>

<h2 id="a-special-awaitable-type">A special awaitable type</h2>

<p>This brings us to
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/blob/deded4441ad895428dc3716852e5fb07c74036af/ReentrantAsyncLock/AsyncLockResult.cs">the <code class="language-plaintext highlighter-rouge">AsyncLockResult</code> class</a>.
This is a special awaitable type and is the thing that lets you asynchronously
get the lock. Microsoft
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#11882-awaitable-expressions">describes</a>
how to make an “awaitable” thing. <code class="language-plaintext highlighter-rouge">AsyncLockResult</code> follows those rules and so
you’re allowed to “await” the thing returned from the <code class="language-plaintext highlighter-rouge">LockAsync</code> method.</p>

<p><code class="language-plaintext highlighter-rouge">AsyncLockResult</code> is really the glue that holds everything together. There are a
couple of competing things going on and this class helps resolve them.</p>

<p>For example, I need to execute asynchronous continuations on a special
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code>, but it’s futile to change the current
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code> within asynchronous code because the previous context
is restored as soon as execution leaves that context. So how do you change the
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code> in the asynchronous code <em>outside of</em> the <code class="language-plaintext highlighter-rouge">LockAsync</code>
method? The answer is to make the <code class="language-plaintext highlighter-rouge">LockAsync</code> method actually be <em>synchronous</em>
but return something that can be awaited—that something is an instance of
<code class="language-plaintext highlighter-rouge">AsyncLockResult</code>.</p>

<p>As another example, the <code class="language-plaintext highlighter-rouge">LockAsync</code> method takes a <code class="language-plaintext highlighter-rouge">CancellationToken</code>, meaning
“please stop trying to acquire the lock as soon as this token is canceled.” But
what if the continuation (for the code following your call to <code class="language-plaintext highlighter-rouge">LockAsync</code>) has
already been posted to the work queue and the work queue is busy? Then you’ll
cancel the <code class="language-plaintext highlighter-rouge">CancellationToken</code> and nothing will happen until the work queue gets
around to processing your continuation. So how do you safely post a continuation
(which by design is only allowed to be executed once) to the work queue <em>and</em>
call it when the <code class="language-plaintext highlighter-rouge">CancellationToken</code> is canceled? Again, the answer is “with the
<code class="language-plaintext highlighter-rouge">AsyncLockResult</code> class.” It wraps the continuation in such a way that it can be
sent to both places at once but will only get executed a single time.</p>

<h1 id="the-point">The point</h1>

<p>The
<a href="https://www.nuget.org/packages/ReentrantAsyncLock">ReentrantAsyncLock NuGet package</a>
is an asynchronous lock that gives you all three of these things with nice
semantics:</p>

<ul>
  <li>Reentrance</li>
  <li>Asynchronicity</li>
  <li>Mutual exclusion</li>
</ul>

<p>Give it a try!</p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[Introducing the ReentrantAsyncLock package]]></summary></entry><entry><title type="html">Questions Answered</title><link href="/programming/2022/06/20/questions-answered.html" rel="alternate" type="text/html" title="Questions Answered" /><published>2022-06-20T00:00:00-05:00</published><updated>2022-06-20T00:00:00-05:00</updated><id>/programming/2022/06/20/questions-answered</id><content type="html" xml:base="/programming/2022/06/20/questions-answered.html"><![CDATA[<p>This is the fourth post in a short series about async
locks:</p>

<ol>
  <li><strong><a href="/programming/2022/06/14/reentrant-async-lock.html">Reentrant Async Lock</a></strong>—A correct implementation</li>
  <li><strong><a href="/programming/2022/06/15/ergonomic-async-lock.html">A More Ergonomic Async Lock (obsolete)</a></strong>—Making the work queue look more like an async lock</li>
  <li><strong><a href="/programming/2022/06/20/introducing-reentrantasynclock.html">ReentrantAsyncLock NuGet Package</a></strong>—Introducing the ReentrantAsyncLock package</li>
  <li><strong>Questions Answered</strong> (<em>this post</em>)—Answering some questions about ReentrantAsyncLock</li>
</ol>

<hr />

<p>This series started because I needed a reentrant asynchronous lock for my job.
We were already using an asynchronous lock but I noticed it deadlocked when you
tried to reenter it. I thought that was silly so I set out to find one that
works. That’s when I found Max Fedotov’s article titled
“Reentrant (Recursive) Async Lock is Impossible in C#”, along with
<a href="https://www.reddit.com/r/dotnet/comments/rklmby/reentrant_recursive_async_lock_is_impossible_in_c/">his Reddit thread</a>
about the same.</p>

<p>I took that as a challenge and set out to prove him wrong. It’s not personal, I
just like a good programming challenge. And it happens that the solution to this
one will satisfy a real world need in my job.</p>

<p>So after publishing
“<a href="/programming/2022/06/14/reentrant-async-lock.html">Reentrant Async Lock</a>” I
linked to it
<a href="https://www.reddit.com/r/dotnet/comments/rklmby/comment/icdr70a/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">in Max’s Reddit thread</a>.</p>

<p>He gave it some thought and then replied with
<a href="https://itnext.io/reentrant-recursive-async-lock-is-impossible-in-c-e9593f4aa38a#:~:text=article%20still%20stands.-,2,-Another%20challenge%20to">an update to his article</a>
and
<a href="https://www.reddit.com/r/dotnet/comments/rklmby/comment/icthvsy/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">a reply on Reddit</a>.</p>

<p>I really appreciate his thoughtful replies—something too often absent from
other people on the internet—and I’d like to address the concerns he
raised. I’ll frame them as questions and then I’ll answer them.</p>

<p>In summary, I think that
<a href="https://www.nuget.org/packages/ReentrantAsyncLock">the ReentrantAsyncLock NuGet package</a>
correctly satisfies the need for a reentrant async lock. And while Max’s
concerns do require consideration I don’t think they are showstoppers.</p>

<h1 id="is-configureawaitfalse-a-problem">Is ConfigureAwait(false) a problem?</h1>

<p>When you await a <code class="language-plaintext highlighter-rouge">Task</code> in C#, you can configure it to take the code after the
await and run it on the thread pool synchronization context instead of returning
to whatever context you were on to begin with.</p>

<p>This can be very handy. And as Max pointed out this is sometimes even
recommended. He points to
<a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">an article written by Stephen Toub</a>
and to
<a href="https://blog.stephencleary.com/2012/02/async-and-await.html#avoiding-context">an article written by Stephen Cleary</a>.
If you’ve been around C# long enough then you’ll recognize both of those names
as heavy hitters. Both Stephens have made significant contributions to the .Net
world and when they say something a lot of people listen. So let’s consider what
they say.</p>

<p>First let me give an example of when <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code> is a good thing.</p>

<p>Pretend that you have written the following library for the world to use. It’s
really useful so a lot of people use your special function. A lot of CPU time
the world over is being spent on your asynchronous function, but burning
dinosaurs isn’t your hobby so you’d like to save some electricity and make it
faster:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLibrary</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSpecialStuffAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="nf">DoFirstThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">DoSecondThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">DoLastThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One way you can do that is by using <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLibrary</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSpecialStuffAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="nf">DoFirstThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">DoSecondThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">DoLastThingAsync</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But <em>should</em> you do that?</p>

<p>Well, it depends on what you’re doing. There is no hard-and-fast rule, but it’s
merely a performance optimization that you can use <em>if it makes sense</em>:</p>

<table>
  <thead>
    <tr>
      <th>What you’re doing</th>
      <th>Use <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code>?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Writing application code</td>
      <td>No (Toub)</td>
    </tr>
    <tr>
      <td>Writing framework code</td>
      <td>Sometimes (Toub, Cleary)</td>
    </tr>
    <tr>
      <td>Something that needs to preserve context</td>
      <td>No (Toub, Cleary)</td>
    </tr>
    <tr>
      <td>Eeking out every last CPU cycle</td>
      <td>Maybe (Toub, Cleary)</td>
    </tr>
    <tr>
      <td>Trying to avoid deadlocks</td>
      <td>Maybe (Toub)</td>
    </tr>
  </tbody>
</table>

<p>As an aside, if you’re trying to avoid deadlocks by using
<code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code> then you’re probably doing it wrong. Why are you
synchronously blocking on a <code class="language-plaintext highlighter-rouge">Task</code> at all?</p>

<p>But here’s the thing: both Stephens agree if you need to preserve the context
then you should not use <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code>. And in the case of
<code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code> that context is the very thing that makes it tick—you
must preserve it, so don’t use <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code>.</p>

<p>Here’s an example of how <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code> can mess up a
<code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoStuffAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span>
    <span class="k">await</span> <span class="nf">DoAsyncIOOperationAsync</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="c1">//                                  ^^^^^^^^^^^^^^^^^^^^^^</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span> <span class="c1">// &lt;-- Uh oh!! Caused by this ^</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That second call to <code class="language-plaintext highlighter-rouge">DoNonThreadSafeStuff()</code> will <strong>not</strong> be guarded by the lock
because you escaped the special synchronization context that the lock uses to
guarantee mutual exclusion.</p>

<p>So when you’re inside the guarded section of a <code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code> I think both
Stephens would say “don’t use <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code>.”</p>

<p>Important!—it doesn’t matter if <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code> is used by
asynchronous methods that you call. Because when execution resumes after those
methods it’ll resume back on the special synchronization context. For example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoStuffAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="nf">DoAsyncIOOperationAsync</span><span class="p">(</span><span class="n">token</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">));</span>
    <span class="c1">//                                                             ^^^^^^^^^^^^^^^^^^^^^^</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span> <span class="c1">// &lt;-- This call is still guarded, even with this ^</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So you really only have to worry about the asynchronous code immediately within
the guarded section of the async lock. And if you’re using the async lock then
that means you are also writing the code in that guarded section—nobody is
talking about some third party function “out there” that you can’t control. So
just don’t use <code class="language-plaintext highlighter-rouge">ConfigureAwait(false)</code> in the immediate guarded section and
you’ll be fine.</p>

<h1 id="can-you-synchronously-block-and-wait-for-other-tasks-in-the-same-synchronization-context">Can you synchronously block and wait for other tasks in the same synchronization context?</h1>

<p>I think the question is if you can do this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomething1Async</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoSomething2Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomething2Async</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoSomething1Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The answer is no. That will deadlock.</p>

<p>But this isn’t an issue with the async lock. The problem is you’ve written
terrible code that deadlocks. The potential for deadlocks is the reason it’s a
code smell to <code class="language-plaintext highlighter-rouge">.Wait()</code> a <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>Note: this deadlocks, too:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomething1Async</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoSomething2Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomething2Async</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="nf">DoSomething1Async</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To be fair, Max also doesn’t think this is really an issue.</p>

<p><strong>Update</strong>: Actually you’ll get stack overflows from those examples. But pretend
for a moment that it deadlocks from the fact that one is waiting on the other
which is waiting on the first. Pretend we’re talking about this instead:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DeadlockAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">tcs</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TaskCompletionSource</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">task1</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">await</span> <span class="n">tcs</span><span class="p">.</span><span class="n">Task</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="kt">var</span> <span class="n">task2</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">tcs</span><span class="p">.</span><span class="nf">TrySetResult</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="k">await</span> <span class="n">task2</span><span class="p">;</span>
  <span class="k">await</span> <span class="n">task1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example there is a race condition between <code class="language-plaintext highlighter-rouge">task1</code> and <code class="language-plaintext highlighter-rouge">task2</code>. If
<code class="language-plaintext highlighter-rouge">task2</code> wins the race then everything is hunky dory. But if <code class="language-plaintext highlighter-rouge">task1</code> wins the
race then there is a deadlock: <code class="language-plaintext highlighter-rouge">task1</code> will be waiting on the <code class="language-plaintext highlighter-rouge">tcs</code> which
can only be set by <code class="language-plaintext highlighter-rouge">task2</code>, but <code class="language-plaintext highlighter-rouge">task2</code> is waiting to acquire the lock and can’t
until <code class="language-plaintext highlighter-rouge">task1</code> releases it.</p>

<p>Let me go into a little more detail about <em>why</em> that would deadlock, and why I
think that’s exactly what should happen.</p>

<p>The reason it deadlocks is because it’s not an example of re-entering the lock.
Two <strong>different</strong> contexts are vying for the lock. Sometimes one of them gets it
and sometimes the other one gets it, but not both at the same time.</p>

<p>And they are two different contexts because they’ll have <em>sibling</em>
<code class="language-plaintext highlighter-rouge">ExecutionContext</code> instead of one “inheriting” from the other.</p>

<p>I think deadlocking is the right thing. Think about the synchronous analogy:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="kt">object</span> <span class="n">_gate</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Deadlock</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">mre</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ManualResetEventSlim</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">thread1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">_gate</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">mre</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="n">thread1</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
  <span class="kt">var</span> <span class="n">thread2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="k">lock</span> <span class="p">(</span><span class="n">_gate</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">mre</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="n">thread2</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

  <span class="n">thread2</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
  <span class="n">thread1</span><span class="p">.</span><span class="nf">Join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I don’t think anyone will complain about the deadlock in the synchronous
analogy. Instead I think they’ll be content to learn that the problem is their
code :)</p>

<h1 id="cant-someone-just-replace-synchronizationcontextcurrent-somewhere-down-the-call-chain-inside-the-guarded-section-of-an-async-lock">Can’t someone just replace SynchronizationContext.Current somewhere down the call chain inside the guarded section of an async lock?</h1>

<p>I think the question here is if this has any effect on the performance of the
lock:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomethingAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ChangeSynchronizationContext</span><span class="p">());</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">ChangeSynchronizationContext</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The answer is: no. When execution returns from the awaited <code class="language-plaintext highlighter-rouge">Task</code> then the
async state machine will have restored the synchronization context to what it
was before awaiting that <code class="language-plaintext highlighter-rouge">Task</code>. So in this case <code class="language-plaintext highlighter-rouge">DoNonThreadSafeStuff()</code> will
still be guarded by the lock.</p>

<p>But perhaps that’s not what Max was getting at. Perhaps he meant this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomethingAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nf">ChangeSynchronizationContext</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">ChangeSynchronizationContext</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The answer here is: yes, that’ll cause <code class="language-plaintext highlighter-rouge">DoNonThreadSafeStuff()</code> to execute on
the thread pool. You’ll have broken the lock.</p>

<p>So don’t do that :)</p>

<p>If you’re concerned about calling third party synchronous functions within the
guarded section of the async lock then you can always package them up into a
<code class="language-plaintext highlighter-rouge">Task.Run</code> and you will never have issues. Like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoSomethingAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ExecuteStrangeThirdPartyFunction</span><span class="p">());</span>
    <span class="nf">DoNonThreadSafeStuff</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="what-about-the-synchronization-context-from-which-you-enter-the-async-lock">What about the synchronization context from which you enter the async lock?</h1>

<p>Max said:</p>

<blockquote>
  <p>There could be another <code class="language-plaintext highlighter-rouge">SynchronizationContext</code> already when you apply your
  lock, so you have to consider if you want to wrap it and post things onto it
  instead of posting them to the thread pool.</p>
</blockquote>

<p>This is a valid concern. Let me illustrate with a pretend WPF example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="c1">// Event handler for the "Click" event on a button named "Button"</span>
<span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">OnButtonClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Button</span><span class="p">.</span><span class="n">Tag</span> <span class="p">=</span> <span class="s">"This works"</span><span class="p">;</span> <span class="c1">// This will work</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="k">default</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">Button</span><span class="p">.</span><span class="n">Tag</span> <span class="p">=</span> <span class="s">"Uh oh!"</span><span class="p">;</span> <span class="c1">// This will throw an exception</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above code illustrates that when a button’s “Click” event handler executes
it’ll do so on the UI thread. But then execution leaves that thread inside the
async lock. This change in threads might be unexpected to developers. The second
assignment to <code class="language-plaintext highlighter-rouge">Button.Tag</code> will throw an exception because in WPF that property
can only be assigned from the thread that is running that button’s dispatcher.</p>

<p>What’s the solution?</p>

<p>In this case you would have to do the following:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">ReentrantAsyncLock</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">OnButtonClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Button</span><span class="p">.</span><span class="n">Tag</span> <span class="p">=</span> <span class="s">"This still works"</span><span class="p">;</span>
  <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="k">default</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">await</span> <span class="n">Button</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">.</span><span class="nf">InvokeAsync</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Button</span><span class="p">.</span><span class="n">Tag</span> <span class="p">=</span> <span class="s">"Now this works, too!"</span><span class="p">);</span> <span class="c1">// No more exception</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While it is not a showstopper, it is something you have to be conscious of. And
I think that’s Max’s point; entering the async lock changes some things that
don’t usually change.</p>

<h1 id="should-the-async-lock-have-a-synchronous-locking-api-too">Should the async lock have a synchronous locking API, too?</h1>

<p>Max points out that many async lock implementations also have synchronous lock
methods. Then the async lock can be used in both synchronous and asynchronous
contexts.</p>

<p>Personally I don’t think that’s a good choice. In fact I would go so far as to
call it an anti-pattern. I personally think that a synchronous lock should be
used for synchronous contexts, and an asynchronous lock should be used for
asynchronous contexts. I suspect that if you want to use one for the other then
there are probably some things going amuck in your code. I think that if you’re
okay with
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">colored functions</a>
then you should also be okay with colored locks.</p>

<p>But I’m writing this in a country where the First Amendment gives citizens the
right to freely express the following extension method, and where copyright law
won’t hamper them because this whole site
<a href="https://github.com/matthew-a-thomas/me/blob/master/LICENSE">is MIT-licensed</a>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ReentrantAsyncLockExtensions</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IDisposable</span> <span class="nf">LockSynchronously</span><span class="p">(</span><span class="k">this</span> <span class="n">ReentrantAsyncLock</span> <span class="n">asyncLock</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">mre</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ManualResetEventSlim</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">lockResult</span> <span class="p">=</span> <span class="n">asyncLock</span><span class="p">.</span><span class="nf">LockAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">awaiter</span> <span class="p">=</span> <span class="n">lockResult</span><span class="p">.</span><span class="nf">GetAwaiter</span><span class="p">();</span>
        <span class="n">awaiter</span><span class="p">.</span><span class="nf">OnCompleted</span><span class="p">(</span><span class="n">mre</span><span class="p">.</span><span class="n">Set</span><span class="p">);</span>
        <span class="n">mre</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span> <span class="c1">// Token has already been given to LockAsync(...) above</span>
        <span class="kt">var</span> <span class="n">asyncDisposable</span> <span class="p">=</span> <span class="n">awaiter</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Disposable</span><span class="p">(()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">_</span> <span class="p">=</span> <span class="n">asyncDisposable</span><span class="p">.</span><span class="nf">DisposeAsync</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Disposable</span> <span class="p">:</span> <span class="n">IDisposable</span>
    <span class="p">{</span>
        <span class="n">Action</span><span class="p">?</span> <span class="n">_dispose</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">Disposable</span><span class="p">(</span><span class="n">Action</span><span class="p">?</span> <span class="n">dispose</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_dispose</span> <span class="p">=</span> <span class="n">dispose</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_dispose</span><span class="p">,</span> <span class="k">null</span><span class="p">)?.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I <em>think</em> that’ll work. It takes into account some of the nuances of
<code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code>.</p>

<p>But no guarantees!</p>

<p>And I don’t like it.</p>

<h1 id="the-point">The point</h1>

<p>I think that <code class="language-plaintext highlighter-rouge">ReentrantAsyncLock</code> provides all the important aspects of an
asynchronous lock. It does sometimes require some careful thought when you use
it, but all of the rough spots that I know of can be addressed and aren’t
showstoppers.</p>

<p>Feel free to <a href="https://www.nuget.org/packages/ReentrantAsyncLock/">try it out</a>
and please
<a href="https://github.com/matthew-a-thomas/cs-reentrant-async-lock/issues/new">report any bugs you find</a>!</p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[Answering some questions about ReentrantAsyncLock]]></summary></entry><entry><title type="html">A More Ergonomic Async Lock (obsolete)</title><link href="/programming/2022/06/15/ergonomic-async-lock.html" rel="alternate" type="text/html" title="A More Ergonomic Async Lock (obsolete)" /><published>2022-06-15T00:00:00-05:00</published><updated>2022-06-15T00:00:00-05:00</updated><id>/programming/2022/06/15/ergonomic-async-lock</id><content type="html" xml:base="/programming/2022/06/15/ergonomic-async-lock.html"><![CDATA[<p>This is the second post in a short series about async
locks:</p>

<ol>
  <li><strong><a href="/programming/2022/06/14/reentrant-async-lock.html">Reentrant Async Lock</a></strong>—A correct implementation</li>
  <li><strong>A More Ergonomic Async Lock (obsolete)</strong> (<em>this post</em>)—Making the work queue look more like an async lock</li>
  <li><strong><a href="/programming/2022/06/20/introducing-reentrantasynclock.html">ReentrantAsyncLock NuGet Package</a></strong>—Introducing the ReentrantAsyncLock package</li>
  <li><strong><a href="/programming/2022/06/20/questions-answered.html">Questions Answered</a></strong>—Answering some questions about ReentrantAsyncLock</li>
</ol>

<hr />

<div class="alert alert-warning">

<h2 id="warning">Warning</h2>

<p>The code described in this post has some issues. For example, the
code below doesn’t correctly handle cancellation. See
<a href="/programming/2022/06/20/introducing-reentrantasynclock.html">the next post</a> for a
better implementation that is more thoroughly tested.</p>

</div>

<p>I previously <a href="/programming/2022/06/14/reentrant-async-lock.html">described</a> how to
make an async lock that supports all three of these at once:</p>

<ul>
  <li>Reentrance</li>
  <li>Asynchronicity</li>
  <li>Mutual exclusion</li>
</ul>

<p>Now I’m going to show how to make it more ergonomic. With
<a href="/programming/2022/06/14/reentrant-async-lock.html">the <code class="language-plaintext highlighter-rouge">WorkQueue</code> class from that post</a>
and with the <code class="language-plaintext highlighter-rouge">EnterAsync</code> extension method shown below you’ll be able to write
code like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">readonly</span> <span class="n">WorkQueue</span> <span class="n">_asyncLock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="k">readonly</span> <span class="kt">object</span> <span class="n">_resource</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

<span class="k">async</span> <span class="n">Task</span> <span class="nf">DoItAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">_asyncLock</span><span class="p">.</span><span class="nf">EnterAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">_resource</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="the-enterasync-extension-method">The <code class="language-plaintext highlighter-rouge">EnterAsync</code> extension method</h2>

<p>This extension method sets <code class="language-plaintext highlighter-rouge">SynchronizationContext.Current</code> to the given
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code>, then asynchronously enters it. When the returned
<code class="language-plaintext highlighter-rouge">IAsyncDisposable</code> is disposed of then <code class="language-plaintext highlighter-rouge">SynchronizationContext.Current</code> will be
reset to whatever it was before.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Runtime.CompilerServices</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">SynchronizationContextExtensions</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">?,</span> <span class="n">IAsyncDisposable</span><span class="p">&gt;</span> <span class="n">CastToAsyncDisposable</span> <span class="p">=</span> <span class="n">state</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">IAsyncDisposable</span><span class="p">)</span><span class="n">state</span><span class="p">!;</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">Action</span> <span class="n">DoNothing</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{};</span>

    <span class="k">static</span> <span class="k">readonly</span> <span class="n">ConditionalWeakTable</span><span class="p">&lt;</span><span class="n">SynchronizationContext</span><span class="p">,</span> <span class="n">TaskFactory</span><span class="p">&gt;</span> <span class="n">SynchronizationContextToTaskFactoryMap</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IAsyncDisposable</span><span class="p">&gt;</span> <span class="nf">EnterAsync</span><span class="p">(</span>
        <span class="k">this</span> <span class="n">SynchronizationContext</span> <span class="n">context</span><span class="p">,</span>
        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cancellationToken</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromCanceled</span><span class="p">&lt;</span><span class="n">IAsyncDisposable</span><span class="p">&gt;(</span><span class="n">cancellationToken</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">previousContext</span> <span class="p">=</span> <span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
        <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">contextFactory</span> <span class="p">=</span> <span class="nf">GetOrCreateTaskFactory</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">disposable</span> <span class="p">=</span> <span class="n">AsyncDisposable</span><span class="p">.</span><span class="nf">Create</span><span class="p">(()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span> <span class="p">==</span> <span class="n">context</span><span class="p">)</span>
                <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="n">previousContext</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">DoNothing</span><span class="p">,</span> <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">ValueTask</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nf">EnterAsyncCore</span><span class="p">(</span><span class="n">contextFactory</span><span class="p">,</span> <span class="n">disposable</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">TaskFactory</span> <span class="nf">GetOrCreateTaskFactory</span><span class="p">(</span><span class="n">SynchronizationContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span> <span class="p">==</span> <span class="n">context</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SynchronizationContextToTaskFactoryMap</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">factory</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">factory</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">scheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="nf">FromCurrentSynchronizationContext</span><span class="p">();</span>
        <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TaskFactory</span><span class="p">(</span><span class="n">scheduler</span><span class="p">);</span>
        <span class="n">SynchronizationContextToTaskFactoryMap</span><span class="p">.</span><span class="nf">AddOrUpdate</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">factory</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IAsyncDisposable</span><span class="p">&gt;</span> <span class="nf">EnterAsyncCore</span><span class="p">(</span>
        <span class="n">TaskFactory</span> <span class="n">taskFactory</span><span class="p">,</span>
        <span class="n">IAsyncDisposable</span> <span class="n">disposable</span><span class="p">,</span>
        <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">taskFactory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(</span><span class="n">CastToAsyncDisposable</span><span class="p">,</span> <span class="n">disposable</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">_</span> <span class="p">=</span> <span class="n">disposable</span><span class="p">.</span><span class="nf">DisposeAsync</span><span class="p">();</span>
            <span class="k">throw</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">AsyncDisposable</span> <span class="p">:</span> <span class="n">IAsyncDisposable</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">AsyncDisposable</span> <span class="n">Empty</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>

    <span class="n">Func</span><span class="p">&lt;</span><span class="n">ValueTask</span><span class="p">&gt;?</span> <span class="n">_disposeAsync</span><span class="p">;</span>

    <span class="nf">AsyncDisposable</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">ValueTask</span><span class="p">&gt;?</span> <span class="n">disposeAsync</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_disposeAsync</span> <span class="p">=</span> <span class="n">disposeAsync</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">AsyncDisposable</span> <span class="nf">Create</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">ValueTask</span><span class="p">&gt;</span> <span class="n">disposeAsync</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span><span class="p">(</span><span class="n">disposeAsync</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">ValueTask</span> <span class="nf">DisposeAsync</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_disposeAsync</span><span class="p">,</span> <span class="k">null</span><span class="p">)?.</span><span class="nf">Invoke</span><span class="p">()</span> <span class="p">??</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-passing-test-case">A passing test case</h2>

<p>The following test passes:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">EnterAsyncMethodShouldSwitchIntoAndOutOfGivenContext</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SynchronizationContext</span><span class="p">.</span><span class="nf">SetSynchronizationContext</span><span class="p">(</span><span class="k">null</span><span class="p">);</span> <span class="c1">// Necessary because xUnit's SynchronizationContexts like to waffle back and forth</span>
    <span class="kt">var</span> <span class="n">newContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SimpleWorkQueue</span><span class="p">();</span>
    <span class="k">await</span> <span class="k">using</span> <span class="p">(</span><span class="k">await</span> <span class="n">newContext</span><span class="p">.</span><span class="nf">EnterAsync</span><span class="p">(</span><span class="k">default</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">Assert</span><span class="p">.</span><span class="nf">Same</span><span class="p">(</span><span class="n">newContext</span><span class="p">,</span> <span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Assert</span><span class="p">.</span><span class="nf">Null</span><span class="p">(</span><span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">isActuallyOutOfTheContext</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">newContext</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="n">isActuallyOutOfTheContext</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">spinWait</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpinWait</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">isActuallyOutOfTheContext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">spinWait</span><span class="p">.</span><span class="nf">SpinOnce</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[Making the work queue look more like an async lock]]></summary></entry><entry><title type="html">Reentrant Async Lock</title><link href="/programming/2022/06/14/reentrant-async-lock.html" rel="alternate" type="text/html" title="Reentrant Async Lock" /><published>2022-06-14T00:00:00-05:00</published><updated>2022-06-14T00:00:00-05:00</updated><id>/programming/2022/06/14/reentrant-async-lock</id><content type="html" xml:base="/programming/2022/06/14/reentrant-async-lock.html"><![CDATA[<p>This is the first post in a short series about async
locks:</p>

<ol>
  <li><strong>Reentrant Async Lock</strong> (<em>this post</em>)—A correct implementation</li>
  <li><strong><a href="/programming/2022/06/15/ergonomic-async-lock.html">A More Ergonomic Async Lock (obsolete)</a></strong>—Making the work queue look more like an async lock</li>
  <li><strong><a href="/programming/2022/06/20/introducing-reentrantasynclock.html">ReentrantAsyncLock NuGet Package</a></strong>—Introducing the ReentrantAsyncLock package</li>
  <li><strong><a href="/programming/2022/06/20/questions-answered.html">Questions Answered</a></strong>—Answering some questions about ReentrantAsyncLock</li>
</ol>

<hr />

<p>Max Fedotov
<a href="https://itnext.io/reentrant-recursive-async-lock-is-impossible-in-c-e9593f4aa38a">wrote</a>:</p>
<blockquote>
  <p>If you need a reentrant async lock — you are out of luck and would have to
  get rid of lock reentry in your code-base instead.</p>
</blockquote>

<p>I’m here to tell you that you are <em>not</em> out of luck. You just need to try harder
;)</p>

<p>Here’s how we’ll have our cake and eat it too:</p>

<ol>
  <li>Make a custom <code class="language-plaintext highlighter-rouge">SynchronizationContext</code></li>
  <li>Make that <code class="language-plaintext highlighter-rouge">SynchronizationContext</code> awaitable</li>
  <li>Use some special semantics</li>
  <li><strong>Update</strong>: improved semantics are shown
<a href="/programming/2022/06/15/ergonomic-async-lock.html">here</a></li>
</ol>

<h2 id="custom-synchronizationcontext">Custom <code class="language-plaintext highlighter-rouge">SynchronizationContext</code></h2>

<p>First, implement a <code class="language-plaintext highlighter-rouge">SynchronizationContext</code> that executes its bits of work
one-at-a-time. Sort of like a <code class="language-plaintext highlighter-rouge">Dispatcher</code> in WPF.</p>

<p>Here’s one I threw together:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections.Concurrent</span><span class="p">;</span>

<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// A &lt;see cref="SynchronizationContext"/&gt; in which units of work are executed one-at-a-time on the thread pool.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">WorkQueue</span> <span class="p">:</span> <span class="n">SynchronizationContext</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Exposes exceptions thrown on this &lt;see cref="SynchronizationContext"/&gt;.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">Exception</span><span class="p">&gt;?</span> <span class="n">ExceptionThrown</span><span class="p">;</span>

    <span class="k">readonly</span> <span class="n">Queue</span><span class="p">&lt;</span><span class="n">Entry</span><span class="p">&gt;</span> <span class="n">_entries</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_gate</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">_isPumping</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">Action</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">?&gt;</span> <span class="n">PumpDelegate</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">SendOrPostCallback</span> <span class="n">SetManualResetEventSlimDelegate</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">ConcurrentBag</span><span class="p">&lt;</span><span class="n">ManualResetEventSlim</span><span class="p">&gt;</span> <span class="n">UnusedManualResetEvents</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">static</span> <span class="nf">WorkQueue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">PumpDelegate</span> <span class="p">=</span> <span class="n">Pump</span><span class="p">;</span>
        <span class="n">SetManualResetEventSlimDelegate</span> <span class="p">=</span> <span class="n">SetManualResetEventSlim</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Returns a new &lt;see cref="WorkQueue"/&gt;.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">public</span> <span class="k">override</span> <span class="n">SynchronizationContext</span> <span class="nf">CreateCopy</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">WorkQueue</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Post</span><span class="p">(</span><span class="n">SendOrPostCallback</span> <span class="n">d</span><span class="p">,</span> <span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_gate</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_entries</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="k">new</span> <span class="nf">Entry</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_isPumping</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="n">_isPumping</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">PumpDelegate</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Pump</span><span class="p">(</span><span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">me</span> <span class="p">=</span> <span class="p">(</span><span class="n">WorkQueue</span><span class="p">)</span><span class="n">state</span><span class="p">!;</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Entry</span> <span class="n">entry</span><span class="p">;</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">me</span><span class="p">.</span><span class="n">_gate</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(!</span><span class="n">me</span><span class="p">.</span><span class="n">_entries</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="n">entry</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">me</span><span class="p">.</span><span class="n">_isPumping</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">entry</span><span class="p">.</span><span class="nf">Callback</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">State</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">me</span><span class="p">.</span><span class="n">ExceptionThrown</span><span class="p">?.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Send</span><span class="p">(</span><span class="n">SendOrPostCallback</span> <span class="n">d</span><span class="p">,</span> <span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">Post</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">UnusedManualResetEvents</span><span class="p">.</span><span class="nf">TryTake</span><span class="p">(</span><span class="k">out</span> <span class="kt">var</span> <span class="n">mre</span><span class="p">))</span>
            <span class="n">mre</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ManualResetEventSlim</span><span class="p">();</span>
        <span class="nf">Post</span><span class="p">(</span><span class="n">SetManualResetEventSlimDelegate</span><span class="p">,</span> <span class="n">mre</span><span class="p">);</span>
        <span class="n">mre</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
        <span class="n">mre</span><span class="p">.</span><span class="nf">Reset</span><span class="p">();</span>
        <span class="n">UnusedManualResetEvents</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">mre</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">SetManualResetEventSlim</span><span class="p">(</span><span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">mre</span> <span class="p">=</span> <span class="p">(</span><span class="n">ManualResetEventSlim</span><span class="p">)</span><span class="n">state</span><span class="p">!;</span>
        <span class="n">mre</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">record</span> <span class="k">struct</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">SendOrPostCallback</span> <span class="n">Callback</span><span class="p">,</span> <span class="kt">object</span><span class="p">?</span> <span class="n">State</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="make-it-awaitable">Make it awaitable</h2>

<p>This <code class="language-plaintext highlighter-rouge">RunBelow()</code> extension method will let you turn every
<code class="language-plaintext highlighter-rouge">SynchronizationContext</code> instance into an
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#11882-awaitable-expressions">awaitable expression</a>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Runtime.CompilerServices</span><span class="p">;</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">SynchronizationContextExtensions</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">AwaitableSynchronizationContext</span> <span class="nf">RunBelow</span><span class="p">(</span><span class="k">this</span> <span class="n">SynchronizationContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">readonly</span> <span class="k">struct</span> <span class="nc">AwaitableSynchronizationContext</span>
<span class="p">{</span>
    <span class="k">readonly</span> <span class="n">SynchronizationContext</span> <span class="n">_synchronizationContext</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AwaitableSynchronizationContext</span><span class="p">(</span><span class="n">SynchronizationContext</span> <span class="n">synchronizationContext</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_synchronizationContext</span> <span class="p">=</span> <span class="n">synchronizationContext</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">SynchronizationContextAwaiter</span> <span class="nf">GetAwaiter</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span><span class="p">(</span><span class="n">_synchronizationContext</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">readonly</span> <span class="k">struct</span> <span class="nc">SynchronizationContextAwaiter</span> <span class="p">:</span> <span class="n">INotifyCompletion</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">readonly</span> <span class="n">SendOrPostCallback</span> <span class="n">InvokeContinuationDelegate</span> <span class="p">=</span> <span class="n">InvokeContinuation</span><span class="p">;</span>
    <span class="k">readonly</span> <span class="n">SynchronizationContext</span> <span class="n">_synchronizationContext</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">SynchronizationContextAwaiter</span><span class="p">(</span><span class="n">SynchronizationContext</span> <span class="n">synchronizationContext</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_synchronizationContext</span> <span class="p">=</span> <span class="n">synchronizationContext</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsCompleted</span> <span class="p">=&gt;</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnCompleted</span><span class="p">(</span><span class="n">Action</span> <span class="n">action</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">_synchronizationContext</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="n">InvokeContinuationDelegate</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">GetResult</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">InvokeContinuation</span><span class="p">(</span><span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">action</span> <span class="p">=</span> <span class="p">(</span><span class="n">Action</span><span class="p">)</span><span class="n">state</span><span class="p">!;</span>
        <span class="nf">action</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="use-special-semantics">Use special semantics</h2>

<p>And now the grand finale…</p>

<p>When you want guarded access, just <code class="language-plaintext highlighter-rouge">await yourWorkQueue.RunBelow()</code>. It’ll be
reentrant, asynchronous, and it provides mutual exclusion:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">SeeItIsPossible</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">isExclusive</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">void</span> <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="kt">object</span> <span class="n">thing</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isExclusive</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">();</span>
        <span class="n">isExclusive</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="n">isExclusive</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">var</span> <span class="n">nonThreadSafeResource</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">asyncGuard</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WorkQueue</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">exceptions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Exception</span><span class="p">&gt;();</span>
    <span class="n">asyncGuard</span><span class="p">.</span><span class="n">ExceptionThrown</span> <span class="p">+=</span> <span class="n">exceptions</span><span class="p">.</span><span class="n">Add</span><span class="p">;</span>
    <span class="k">async</span> <span class="n">Task</span> <span class="nf">RecursivelyUseIt</span><span class="p">(</span><span class="kt">int</span> <span class="n">recursionLevel</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">recursionLevel</span> <span class="p">&gt;</span> <span class="m">10</span><span class="p">)</span>
            <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">await</span> <span class="nf">RecursivelyUseIt</span><span class="p">(</span><span class="n">recursionLevel</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span>
        <span class="nf">RecursivelyUseIt</span><span class="p">(</span><span class="m">0</span><span class="p">),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
                <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
                <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
                <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
                <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}),</span>
        <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">await</span> <span class="n">asyncGuard</span><span class="p">.</span><span class="nf">RunBelow</span><span class="p">();</span>
                <span class="nf">ExclusivelyUse</span><span class="p">(</span><span class="n">nonThreadSafeResource</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">);</span>
    <span class="n">Assert</span><span class="p">.</span><span class="nf">Empty</span><span class="p">(</span><span class="n">exceptions</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="the-point">The point</h2>

<p>You might think it’s impossible to get all three of these at the same time:</p>

<ul>
  <li>Reentrance</li>
  <li>Asynchronicity</li>
  <li>Mutual exclusion</li>
</ul>

<p>But it becomes possible when you take control of the continuations in
asynchronous contexts.</p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[A correct implementation]]></summary></entry><entry><title type="html">Loading Loose XAML</title><link href="/programming/2022/06/03/loading-loose-xaml.html" rel="alternate" type="text/html" title="Loading Loose XAML" /><published>2022-06-03T00:00:00-05:00</published><updated>2022-06-03T00:00:00-05:00</updated><id>/programming/2022/06/03/loading-loose-xaml</id><content type="html" xml:base="/programming/2022/06/03/loading-loose-xaml.html"><![CDATA[<p>Suppose you have a custom thingy like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">LooseXaml</span><span class="p">;</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">CustomThingy</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Property</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>…and you declare it in some XAML:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;CustomThingy</span> <span class="na">xmlns=</span><span class="s">"clr-namespace:LooseXaml"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;CustomThingy.Property&gt;</span>Hello, world!<span class="nt">&lt;/CustomThingy.Property&gt;</span>
<span class="nt">&lt;/CustomThingy&gt;</span>
</code></pre></div></div>

<p>…and that XAML is in a file named “EmbeddedResource.xaml”, which is an
embedded resource:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;net6.0-windows&lt;/TargetFramework&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
      &lt;Page Remove="EmbeddedResource.xaml" /&gt;
      &lt;EmbeddedResource Include="EmbeddedResource.xaml" /&gt;
    &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre></div></div>

<p>Did you know you can parse and instantiate it?</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">LooseXaml</span><span class="p">;</span>

<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Windows</span><span class="p">;</span>

<span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">App</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnStartup</span><span class="p">(</span><span class="n">StartupEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="nf">GetType</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">Assembly</span><span class="p">;</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">assembly</span><span class="p">.</span><span class="nf">GetManifestResourceStream</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="s">"EmbeddedResource.xaml"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Wrong resource name"</span><span class="p">);</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StreamReader</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">loader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Loader</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">customThingy</span> <span class="p">=</span> <span class="n">loader</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">CustomThingy</span><span class="p">&gt;(</span>
            <span class="n">reader</span><span class="p">,</span>
            <span class="n">assembly</span><span class="p">,</span>
            <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="n">assembly</span> <span class="p">}</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">customThingy</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Failed to load it. Are you sure that XAML declares a CustomThingy?"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">customThingy</span><span class="p">.</span><span class="n">Property</span> <span class="p">!=</span> <span class="s">"Hello, world!"</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Loaded it, but its property is wrong for some reason"</span><span class="p">);</span>
        <span class="n">Trace</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"It works!"</span><span class="p">);</span>
        <span class="n">Environment</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="the-loader">The loader</h2>

<p>Here’s how:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">LooseXaml</span><span class="p">;</span>

<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Xaml</span><span class="p">;</span>

<span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Loader</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span><span class="p">?</span> <span class="n">Load</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
        <span class="n">TextReader</span> <span class="n">textReader</span><span class="p">,</span>
        <span class="n">Assembly</span> <span class="n">localAssembly</span><span class="p">,</span>
        <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Assembly</span><span class="p">&gt;</span> <span class="n">assemblies</span><span class="p">)</span>
        <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="err">{</span>
        <span class="nc">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XamlSchemaContext</span><span class="p">(</span><span class="n">assemblies</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">settings</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XamlXmlReaderSettings</span>
        <span class="p">{</span>
            <span class="n">LocalAssembly</span> <span class="p">=</span> <span class="n">localAssembly</span><span class="p">,</span>
            <span class="n">ProvideLineInfo</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
            <span class="n">AllowProtectedMembersOnRoot</span> <span class="p">=</span> <span class="k">true</span>
        <span class="p">};</span>
        <span class="k">using</span> <span class="nn">var</span> <span class="n">xamlXmlReader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XamlXmlReader</span><span class="p">(</span>
            <span class="n">textReader</span><span class="p">,</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="n">settings</span>
        <span class="p">);</span>
        <span class="kt">var</span> <span class="n">root</span> <span class="p">=</span> <span class="n">XamlServices</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">xamlXmlReader</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span> <span class="k">as</span> <span class="n">T</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="things-to-remember">Things to remember</h2>

<h3 id="xaml-only-supports-parameterless-constructors">XAML only supports parameterless constructors</h3>

<p>Well, technically you can use the
<a href="https://docs.microsoft.com/en-us/dotnet/desktop/xaml-services/xfactorymethod-directive"><code class="language-plaintext highlighter-rouge">x:FactoryMethod</code></a>
or
<a href="https://docs.microsoft.com/en-us/dotnet/desktop/xaml-services/xarguments-directive"><code class="language-plaintext highlighter-rouge">x:Arguments</code></a>
directives.</p>

<p>If you do that then remember to include the
<code class="language-plaintext highlighter-rouge">xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</code> namespace in your XAML.</p>

<h3 id="xamlxmlreadersettingslocalassembly-is-important"><code class="language-plaintext highlighter-rouge">XamlXmlReaderSettings.LocalAssembly</code> is important</h3>

<p>According to
<a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml?view=netframeworkdesktop-4.8#mapping-to-current-assemblies">Microsoft’s documentation</a>
you can omit the <code class="language-plaintext highlighter-rouge">;assembly=YourAssembly</code> part of
<code class="language-plaintext highlighter-rouge">xmlns="clr-namespace:YourNamespace;assembly=YourAssembly"</code>.</p>

<p>When you do then it’ll assume you’re talking about the current assembly. Which
is what <code class="language-plaintext highlighter-rouge">XamlXmlReaderSettings.LocalAssembly</code> points to. So you need to set that
property to the current assembly.</p>

<h2 id="the-point">The point</h2>

<p>You can use XAML for more than just WPF!</p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[How to parse and load XAML from an embedded resource]]></summary></entry><entry><title type="html">Square Roots and Primes</title><link href="/numbers/2022/05/19/square-roots-primes.html" rel="alternate" type="text/html" title="Square Roots and Primes" /><published>2022-05-19T00:00:00-05:00</published><updated>2022-05-19T00:00:00-05:00</updated><id>/numbers/2022/05/19/square-roots-primes</id><content type="html" xml:base="/numbers/2022/05/19/square-roots-primes.html"><![CDATA[<p>At the end of
<a href="/programming/2020/10/27/making-primes-rust.html">Making Prime Numbers in Rust</a>
I explained how to make a prime number generator. It used trial division. You’ll
notice that I don’t bother trying to divide the candidate number by any prime
larger than its square root.</p>

<p>Why the square root?</p>

<h2 id="graphical-answer">Graphical answer</h2>

<div class="d-flex flex-column">
  <div>100 divided by <span id="divisor-output">10</span></div>
  <input type="range" id="divisor" min="1" value="10" />
  <div>...equals <span id="quotient-output">10</span></div>
  <input type="range" id="quotient" min="1" step="0.1" value="10" disabled="" />
</div>
<script>
  const divisor = document.getElementById('divisor');
  const divisorOutput = document.getElementById('divisor-output');
  const quotient = document.getElementById('quotient');
  const quotientOutput = document.getElementById('quotient-output');
  function updateQuotient() {
    quotient.value = 100 / divisor.value;
    divisorOutput.innerHTML = divisor.value;
    quotientOutput.innerHTML = quotient.value;
  }
  divisor.addEventListener('input', updateQuotient);
</script>

<p><br />
Play with the top slider for a bit.</p>

<p>Do you get it yet?</p>

<p>Here’s a hint: once you’ve figured out that \(100 \div 2 = 50\), you then also
know that \(100 \div 50 = 2\). There’s no need to also divide by 50 because you
already know that answer.</p>

<p>The same goes for all these:</p>

<table>
  <thead>
    <tr>
      <th>100 divided by</th>
      <th>equals</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>50</td>
    </tr>
    <tr>
      <td>3</td>
      <td>33.3</td>
    </tr>
    <tr>
      <td>5</td>
      <td>20</td>
    </tr>
    <tr>
      <td>7</td>
      <td>14.3</td>
    </tr>
    <tr>
      <td>11</td>
      <td>9.1</td>
    </tr>
    <tr>
      <td>13</td>
      <td>7.7</td>
    </tr>
    <tr>
      <td>17</td>
      <td>5.9</td>
    </tr>
    <tr>
      <td>19</td>
      <td>5.3</td>
    </tr>
  </tbody>
</table>

<p>What do you notice about each of those pairs of numbers?</p>

<p>The square root is always at least as large as one of them.</p>

<p>Once you’ve divided by primes up through the square root then you already know
the answers for all the primes larger than the square root. So there’s no need
to also divide by those larger primes.</p>]]></content><author><name></name></author><category term="numbers" /><summary type="html"><![CDATA[Why square roots are used in trial division]]></summary></entry><entry><title type="html">Dynamically Generated Type</title><link href="/programming/2022/02/22/generated-type.html" rel="alternate" type="text/html" title="Dynamically Generated Type" /><published>2022-02-22T00:00:00-06:00</published><updated>2022-02-22T00:00:00-06:00</updated><id>/programming/2022/02/22/generated-type</id><content type="html" xml:base="/programming/2022/02/22/generated-type.html"><![CDATA[<p>There are a variety of ways to interact with C#’s type system. You
can:</p>
<ul>
  <li>Reflect over existing types</li>
  <li>Generate types
    <ul>
      <li>Statically at compile time
        <ul>
          <li>The normal way</li>
          <li>With code generation</li>
        </ul>
      </li>
      <li><strong>Dynamically at runtime</strong></li>
    </ul>
  </li>
</ul>

<p>Here’s some code that does that last category:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">Example</span><span class="p">;</span>

<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection.Emit</span><span class="p">;</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IFace</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="nf">Go</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">IFace</span> <span class="nf">Create</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">assemblyBuilder</span> <span class="p">=</span> <span class="n">AssemblyBuilder</span><span class="p">.</span><span class="nf">DefineDynamicAssembly</span><span class="p">(</span>
            <span class="k">new</span> <span class="nf">AssemblyName</span><span class="p">(</span><span class="s">"Generated"</span><span class="p">),</span>
            <span class="n">AssemblyBuilderAccess</span><span class="p">.</span><span class="n">Run</span>
        <span class="p">);</span>
        <span class="kt">var</span> <span class="n">moduleBuilder</span> <span class="p">=</span> <span class="n">assemblyBuilder</span><span class="p">.</span><span class="nf">DefineDynamicModule</span><span class="p">(</span><span class="s">"Generated"</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">typeBuilder</span> <span class="p">=</span> <span class="n">moduleBuilder</span><span class="p">.</span><span class="nf">DefineType</span><span class="p">(</span><span class="s">"GeneratedType"</span><span class="p">,</span> <span class="n">TypeAttributes</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">TypeAttributes</span><span class="p">.</span><span class="n">Class</span><span class="p">);</span>
        <span class="n">typeBuilder</span><span class="p">.</span><span class="nf">AddInterfaceImplementation</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IFace</span><span class="p">));</span>
        <span class="kt">var</span> <span class="n">methodBuilder</span> <span class="p">=</span> <span class="n">typeBuilder</span><span class="p">.</span><span class="nf">DefineMethod</span><span class="p">(</span><span class="s">"Go"</span><span class="p">,</span> <span class="n">MethodAttributes</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">MethodAttributes</span><span class="p">.</span><span class="n">Virtual</span><span class="p">,</span> <span class="n">CallingConventions</span><span class="p">.</span><span class="n">HasThis</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">),</span> <span class="n">Type</span><span class="p">.</span><span class="n">EmptyTypes</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">generator</span> <span class="p">=</span> <span class="n">methodBuilder</span><span class="p">.</span><span class="nf">GetILGenerator</span><span class="p">();</span>
        <span class="n">generator</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldstr</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="nf">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ret</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">typeBuilder</span><span class="p">.</span><span class="nf">CreateType</span><span class="p">()!;</span>
        <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="n">Activator</span><span class="p">.</span><span class="nf">CreateInstance</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">IFace</span><span class="p">)</span><span class="n">instance</span><span class="p">!;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="nf">Create</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="nf">Go</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, world!
</code></pre></div></div>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[How to dynamically generate a type at runtime in C#]]></summary></entry><entry><title type="html">Rust Traits</title><link href="/programming/2022/02/08/rust-traits-for-csharp-devs.html" rel="alternate" type="text/html" title="Rust Traits" /><published>2022-02-08T00:00:00-06:00</published><updated>2022-02-08T00:00:00-06:00</updated><id>/programming/2022/02/08/rust-traits-for-csharp-devs</id><content type="html" xml:base="/programming/2022/02/08/rust-traits-for-csharp-devs.html"><![CDATA[<p>The <a href="https://www.rust-lang.org/">Rust</a> programming language relies heavily on
<em>traits</em>. But what are they? How do they compare to C#’s interfaces?</p>

<p>In a nutshell, a trait is like a C# interface:</p>
<ul>
  <li>Multiple types can implement it</li>
  <li>You can write code that abstracts over it</li>
  <li>You can do dynamic dispatch with it</li>
  <li>You can write default methods for it</li>
</ul>

<p>…but it is also <em>not</em> like a C# interface:</p>
<ul>
  <li>You can implement a trait for a foreign type</li>
  <li>A trait can have associated types</li>
</ul>

<p>Let’s look at each of these in turn.</p>

<h2 id="like-a-c-interface">Like a C# interface</h2>

<p>The similarities are simple. So I’ll go quick.</p>

<h3 id="multiple-types-can-implement-it">Multiple types can implement it</h3>

<p>In C#, multiple types can implement an interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IFoo</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">ThingA</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Bar</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thing A"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">ThingB</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Bar</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thing B"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The same is true of traits in Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ThingA</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">ThingA</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Thing A"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ThingB</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">ThingB</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Thing B"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="you-can-write-code-that-abstracts-over-it">You can write code that abstracts over it</h3>

<p>In C# you can abstract over an interface:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IBinaryOperator</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="nf">Operate</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Add</span> <span class="p">:</span> <span class="n">IBinaryOperator</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">double</span> <span class="nf">Operate</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Multiply</span> <span class="p">:</span> <span class="n">IBinaryOperator</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">double</span> <span class="nf">Operate</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="n">Apply</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">op</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IBinaryOperator</span> <span class="p">=&gt;</span>
  <span class="n">op</span><span class="p">.</span><span class="nf">Operate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the same is true of Rust’s traits:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">BinaryOperator</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">operate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nb">Add</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">BinaryOperator</span> <span class="k">for</span> <span class="nb">Add</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">operate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Multiply</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">BinaryOperator</span> <span class="k">for</span> <span class="n">Multiply</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">operate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">apply</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
  <span class="n">op</span><span class="nf">.operate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="you-can-do-dynamic-dispatch-with-it">You can do dynamic dispatch with it</h3>

<p>Dynamic dispatch happens so often in C# that we usually don’t notice it. But
here’s an example of dynamic vs static dispatch in action:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IFoo</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">void</span> <span class="nf">DynamicDispatch</span><span class="p">(</span><span class="n">IFoo</span> <span class="n">foo</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">foo</span><span class="p">.</span><span class="nf">bar</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">void</span> <span class="n">StaticDispatch</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">foo</span><span class="p">)</span>
  <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IFoo</span>
  <span class="p">{</span>
    <span class="n">foo</span><span class="p">.</span><span class="nf">bar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the same picture in Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">dynamic_dispatch</span><span class="p">(</span><span class="n">foo</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="nf">.bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">static_dispatch</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="nf">.bar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="you-can-write-default-methods-for-it">You can write default methods for it</h3>

<p>One of the recent versions of C# added default interface implementations. I’m
writing this off the cuff, but I think it looks like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IFoo</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Bar</span><span class="p">();</span>

  <span class="k">void</span> <span class="nf">Baz</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">Bar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Thing</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Bar</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// This is the only method we're required to implement</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s very similar in Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>

  <span class="k">fn</span> <span class="nf">baz</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.bar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Thing</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="n">Thing</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// This is the only method we're required to implement</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="not-like-a-c-interface">Not like a C# interface</h2>

<p>In my opinion this is where Rust’s trait system really begins to shine.</p>

<h3 id="you-can-implement-a-trait-for-a-foreign-type">You can implement a trait for a foreign type</h3>

<p>In C#, when you use a type from some package you found on Nuget or in the
framework (or anywhere for that matter), you’re stuck with whatever interfaces
they decided to implement on that type.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="k">this</span><span class="p">[</span><span class="kt">int</span> <span class="n">index</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">void</span> <span class="n">DoImportantStuff</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">indexable</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Very important things happen here. We don't want to repeat ourselves so</span>
    <span class="c1">// we've encapsulated the behavior into this function and we're trying to</span>
    <span class="c1">// make it work for multiple types by abstracting with generics.</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">void</span> <span class="nf">WontWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">array</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span> <span class="p">};</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="n">array</span><span class="p">);</span> <span class="c1">// Compile error: the array doesn't implement the interface!</span>
    <span class="kt">var</span> <span class="n">span</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">AsSpan</span><span class="p">();</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="n">span</span><span class="p">);</span> <span class="c1">// Compile error: Span doesn't implement the interface!</span>
    <span class="kt">var</span> <span class="n">memory</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">AsMemory</span><span class="p">();</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span> <span class="c1">// Compile error: Memory doesn't implement the interface!</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The adapter pattern will come to your rescue:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArrayReadableIndexAdapter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">T</span><span class="p">[]</span> <span class="n">_array</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ArrayReadableIndexAdapter</span><span class="p">(</span><span class="n">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_array</span> <span class="p">=</span> <span class="n">array</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">T</span> <span class="k">this</span><span class="p">[</span><span class="kt">int</span> <span class="n">index</span><span class="p">]</span> <span class="p">=&gt;</span> <span class="n">_array</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">ref</span> <span class="k">struct</span> <span class="nc">SpanReadableIndexAdapter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">Span</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_span</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SpanReadableIndexAdapter</span><span class="p">(</span><span class="n">Span</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">span</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_span</span> <span class="p">=</span> <span class="n">span</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">T</span> <span class="k">this</span><span class="p">[</span><span class="kt">int</span> <span class="n">index</span><span class="p">]</span> <span class="p">=&gt;</span> <span class="n">_span</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">MemoryReadableIndexAdapter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">readonly</span> <span class="n">Memory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_memory</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MemoryReadableIndexAdapter</span><span class="p">(</span><span class="n">Memory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">memory</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_memory</span> <span class="p">=</span> <span class="n">memory</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">T</span> <span class="k">this</span><span class="p">[</span><span class="kt">int</span> <span class="n">index</span><span class="p">]</span> <span class="p">=&gt;</span> <span class="n">_memory</span><span class="p">.</span><span class="n">Span</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">void</span> <span class="n">DoImportantStuff</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">IReadableIndex</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">indexable</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Same important stuff as before</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">void</span> <span class="nf">WillWork</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">array</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span> <span class="p">};</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="k">new</span> <span class="nf">ArrayReadableIndexAdapter</span><span class="p">(</span><span class="n">array</span><span class="p">));</span>
    <span class="kt">var</span> <span class="n">span</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">AsSpan</span><span class="p">();</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="k">new</span> <span class="nf">SpanReadableIndexAdapter</span><span class="p">(</span><span class="n">span</span><span class="p">));</span>
    <span class="kt">var</span> <span class="n">memory</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">AsMemory</span><span class="p">();</span>
    <span class="nf">DoImportantStuff</span><span class="p">(</span><span class="k">new</span> <span class="nf">MemoryReadableIndexAdapter</span><span class="p">(</span><span class="n">memory</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But the adapter pattern comes with a cost. Do you see all the boilerplate? We
were trying to follow the <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a>
which says:</p>
<blockquote>
  <p>ISP splits interfaces that are very large into smaller and more specific ones
  so that <strong>clients will only have to know about the methods that are of
  interest to them</strong>.</p>
</blockquote>

<p>Indeed we were following it, because the <code class="language-plaintext highlighter-rouge">IReadableIndex&lt;T&gt;</code> interface exposes
the absolute minimum surface area needed for our “important stuff” method. But
to do so we had to introduce a <em>lot</em> of boilerplate!</p>

<p>Rust makes this much easier!</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Idx</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Implement for arrays</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="p">[</span><span class="n">T</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Implement for lists</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// etc</span>

<span class="c1">// Now just use the trait!</span>
<span class="k">fn</span> <span class="n">do_important_stuff</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Index</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">indexable</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Important code here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(The astute reader will notice that Rust already has <a href="https://doc.rust-lang.org/core/ops/trait.Index.html">this trait</a>)</p>

<p>Did you notice how it was possible to implement the trait for <em>foreign</em> types?
It doesn’t matter that we don’t have access to the source code of <code class="language-plaintext highlighter-rouge">[T; N]</code> or
<code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code>. We could still make those types implement this trait, and we didn’t
have to introduce any additional types!</p>

<p>It is often much easier in Rust to <em>tailor interfaces to consumers</em>.</p>

<p>To me it seems Microsoft has fallen in love with a form of programming by
convention which they usually apply
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges#implicit-range-support">like this</a>:</p>
<blockquote>
  <p>The language will provide an instance indexer member with a single parameter
  of type <code class="language-plaintext highlighter-rouge">Range</code> for types which meet the following criteria:</p>
  <ul>
    <li>The type is Countable.</li>
    <li>The type has an accessible member named <code class="language-plaintext highlighter-rouge">Slice</code> which has two parameters of
  type <code class="language-plaintext highlighter-rouge">int</code>.</li>
    <li>The type does not have an instance indexer which takes a single <code class="language-plaintext highlighter-rouge">Range</code> as
  the first parameter. The <code class="language-plaintext highlighter-rouge">Range</code> must be the only parameter or the remaining
  parameters must be optional.</li>
  </ul>

  <p>For such types, the language will bind as if there is an indexer member of the
  form <code class="language-plaintext highlighter-rouge">T this[Range range]</code> where <code class="language-plaintext highlighter-rouge">T</code> is the return type of the <code class="language-plaintext highlighter-rouge">Slice</code> method
  including any <code class="language-plaintext highlighter-rouge">ref</code> style annotations. The new member will also have matching
  accessibility with <code class="language-plaintext highlighter-rouge">Slice</code>.</p>
</blockquote>

<p>Ignore the minutiae. The thing I want you to notice is how they didn’t bother to
give us an interface for this new functionality. Instead they said “if you put
this here and name this other thing a certain way then the compiler will
magically do this”. <em>They gave us no help with abstracting over this behavior in
C#.</em> If you wanted to write code that would work for “range-aware” types then
you’d have to create an interface and adapters for all the different types. (And
once you’ve done that then who cares about <em>implicit</em> range support?)</p>

<p>The benefit that Rust’s traits would bring to this situation is there would be
far less boilerplate and <em>no additional types</em> needed to abstract over the very
same feature! Actually, they have already
<a href="https://doc.rust-lang.org/core/ops/trait.Index.html#impl-Index%3CI%3E-1">done</a>
<a href="https://doc.rust-lang.org/core/ops/struct.Range.html#impl-SliceIndex%3C%5BT%5D%3E">this</a>.</p>

<h3 id="a-trait-can-have-associated-types">A trait can have associated types</h3>

<p>In C#, an interface may have:</p>
<ul>
  <li>Methods</li>
  <li>Properties (which are just syntax sugar for methods)</li>
</ul>

<p>But in Rust, a trait may have:</p>
<ul>
  <li>Methods</li>
  <li>Associated types</li>
</ul>

<p>For example, how would you represent this in C#?</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Rhs</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">Bar</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">Baz</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Baz</span><span class="p">;</span>
  <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Bar</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Baz</span> <span class="p">{</span>
    <span class="c1">// Make a baz from this foo and the given bar</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span> <span class="p">{};</span>
<span class="k">let</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span> <span class="p">{};</span>
<span class="k">let</span> <span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="n">bar</span><span class="p">;</span>
</code></pre></div></div>

<p>I think in C# the interface would have to look like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="nc">IAdd</span><span class="p">&lt;</span><span class="n">TRight</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="n">TOut</span> <span class="nf">Add</span><span class="p">(</span><span class="n">TRight</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But then you have a second generic type parameter that you have to carry
everywhere.</p>

<p>Rust’s associated types are great for hiding generic types in certain
situations. You can even have associated <em>constants</em> (although support for that
isn’t yet complete).</p>

<hr />

<p><em>Caution: the code in this article was written off the cuff and on the fly. It
probably won’t compile.</em></p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[Explained for C# developers]]></summary></entry><entry><title type="html">Multi-Wire Branch Circuit</title><link href="/diy/2021/11/19/mwbc.html" rel="alternate" type="text/html" title="Multi-Wire Branch Circuit" /><published>2021-11-19T00:00:00-06:00</published><updated>2021-11-19T00:00:00-06:00</updated><id>/diy/2021/11/19/mwbc</id><content type="html" xml:base="/diy/2021/11/19/mwbc.html"><![CDATA[<p>I’m having an electrical sub panel installed in my garage. I’ve always wanted
more lights and outlets than the current circuits can handle. And plus I’m
beginning to need 240V for power tools.</p>

<p>As I plan ahead I’m having to learn about all the different outlets, wire
gauges, breakers, and circuits related to both 120V and 240V.</p>

<p>One thing I’m learning about is something called a multi-wire branch circuit
(MWBC).</p>

<h2 id="what-is-a-mwbc">What is a MWBC</h2>

<p>A MWBC gives you two circuits that are out of phase and share a neutral.</p>

<p>Here in the United States the electrical service that comes into your house is
essentially a MWBC. Generally half of the 120V appliances will be on one leg and
the other half will be on the other leg. Bigger appliances that require 240V
service, like an electric stove or HVAC system, will be wired across both legs.
Like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Transformer | Electrical panel | Appliances

+120V ------ ------------------ ---+-------------+
                                    \             \
                                     | Fridge      |
                                    /              |
Neutral ---- ------------------ ---+               | Stove
                                    \              |
                                     | Microwave   |
                                    /             /
-120V ------ ------------------ ---+-------------+
</code></pre></div></div>

<p>Notice how the 120V fridge and microwave share a common neutral?</p>

<h2 id="how-does-it-work">How does it work?</h2>

<p>It’s important that the two 120V legs are exactly out of phase. When they are
out of phase then the neutral line only has to carry the <em>difference</em> in current
between the two legs. But if the two legs are in phase then it has to carry the
<em>sum</em> of the currents.</p>

<p>In a MWBC (where the 120V legs are out of phase) you can use the same gauge wire
for the neutral as for the two legs. In other words you can use a single 12/3
copper wire to feed two 20A 120V circuits. The highest load the neutral will see
is when one leg is using a lot of current and the other is using none.
Paradoxically, the neutral will see zero current when both legs are using
exactly the same amount of current.</p>

<p>But if the legs were in phase then the neutral would have to be sized to carry
twice the capacity of the legs. The highest load the neutral would see in that
case is when both legs are using a lot of current. And the neutral would only
ever see zero current when neither leg is using any current.</p>

<p>Here’s why: in a MWBC if the two legs are using the same amount of current then
the same amount of current will be flowing into one leg as <em>out</em> the other,
because they are exactly out of phase. But if they were in phase then the same
amount of current would be flowing into one leg as <em>into</em> the other, and those
two currents have nowhere to go but through the neutral.</p>

<h2 id="how-do-you-make-one">How do you make one?</h2>

<p>Pick an amperage, like 20A. Get a 20A double pole breaker and some 12/3 (which
is rated for 20A) and a NEMA 5-20 (which is rated for 120V 20A) duplex outlet.
The 12/3 will have four conductors in it:</p>
<ul>
  <li>Black - one 120V leg</li>
  <li>White - neutral</li>
  <li>Red - the other 120V leg</li>
  <li>Bare copper - ground</li>
</ul>

<p>Because you’re using a double pole breaker then the black and red lines will be
out of phase.</p>

<p>Break the hot tab on your duplex outlet so that the hot side of the two
receptacles are no longer electrically connected.</p>

<p>Then wire it like this:</p>
<ul>
  <li>Black -&gt; one receptacle</li>
  <li>Neutral -&gt; shared neutral</li>
  <li>Red -&gt; the other receptacle</li>
  <li>Ground -&gt; shared ground</li>
</ul>

<p>Tada! You now have an outlet that can pump 20A out of both receptacles at once!</p>

<h2 id="rules">Rules</h2>

<p>In addition to all the rules for normal wiring, a MWBC additionally has these
requirements:</p>

<p>When you flip a breaker it has to turn off both legs. This is to prevent any
nasty surprises when someone flips the breaker to do work inside the outlet’s
box—you want both legs to be dead, not just one of them. A double pole
breaker solves this.</p>

<p>You also must take care that you don’t lose the neutral. If you want a MWBC to
feed multiple outlets (not just multiple receptacles, but multiple outlets in a
room) then you have to wire them together in a way that keeps the neutral
connected for all the other outlets if you remove an outlet, or if the neutral
breaks or falls off of an outlet. If you lose the neutral on our example MWBC
above then there will still be 240V between the two hot sides of the receptacles
exactly as there was before. Which in theory is fine without the neutral if both
receptacles are pulling the exact same amount of current. But as soon as there
is a current imbalance then there will be a voltage imbalance—one device
might see 200V while the other only sees 40V—a good way to start a fire.
You also get odd behavior such as lights only working while the toaster is on.
Wiring the outlets in with pigtails helps to keep the integrity of the neutral
line independent of the integrity of the outlet.</p>

<h2 id="the-point">The point</h2>

<p>A MWBC has to be wired properly to work. But it can be a useful way to get lots
of power out of a single duplex outlet. Or a useful way to put a NEMA 6-20
outlet in the same box as a duplex NEMA 5-20 outlet with only a single 12/3
wire.</p>]]></content><author><name></name></author><category term="diy" /><summary type="html"><![CDATA[Learn with me]]></summary></entry></feed>